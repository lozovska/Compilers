% Лабораторная работа №2.1. Синтаксические деревья
% 2 марта 2023 г.
% Карина Лозовска, ИУ9И-64Б

# Цель работы
Целью данной работы является изучение представления синтаксических деревьев в памяти компилятора и приобретение навыков преобразования синтаксических деревьев.

# Индивидуальный вариант
Во всех вызовах функции fmt.Printf добавить в форматную строку префикс вида ```LINE(FUNC_NAME):```, 
где LINE — текущий номер строки, FUNC_NAME — имя функции, из которой происходит вызов ```fmt.Printf```.

# Реализация
В коде используется пакет абстрактного синтаксического дерева (AST) языка Go для проверки исходного файла Go и замены любого вызова функции Printf модифицированной версией этого вызова.
1. Функция ast.Inspect вызывается с двумя аргументами: первый аргумент — это узел *ast.File, представляющий исходный файл Go для проверки, а второй аргумент — это функция, которая будет вызываться для каждого узла в AST.
2. Функция, переданная в качестве второго аргумента, является анонимной функцией, которая принимает ast.Node в качестве входных данных и возвращает логическое значение. Функция определяется с использованием сокращенной записи, в которой тело функции не заключено в фигурные скобки. Вместо этого тело функции сразу следует за объявлением bool func(n ast.Node).
3. Внутри анонимной функции аргумент n приводится к типу *ast.FuncDecl с использованием утверждения типа, а затем для переменной ok устанавливается значение true, если утверждение было успешным. Это проверяет, является ли текущий узел AST объявлением функции.
4. Если ok равно true, имя функции извлекается и присваивается переменной nameoffunc, а тело функции присваивается переменной body.
5. Инициируется цикл для перебора всех операторов в теле функции.
6. Для каждого оператора переменная hzwhatido устанавливается на выполняемое выражение вызова. Это делается с помощью серии утверждений типа для извлечения необходимых частей выражения.
Если выражение вызова является вызовом Printf, то извлекаются номер строки вызова, имя функции и исходная строка, переданная в качестве аргумента Printf.
7. Эти фрагменты информации объединяются для создания новой строки, которая будет использоваться в качестве первого аргумента модифицированного вызова Printf.
8. Исходный строковый аргумент в вызове Printf заменяется новой строкой с использованием утверждения другого типа.
9. Наконец, функция возвращает значение true, чтобы указать, что AST следует продолжать проверять.
```golang 
ast.Inspect(file, func(n ast.Node) bool {
	functions, ok := n.(*ast.FuncDecl)
	if ok {
		nameoffunc := functions.Name.Name
		body := functions.Body
		for i := 0; i < len(body.List); i++ {
			hzwhatido := body.List[i].(*ast.ExprStmt).X.(*ast.CallExpr)
			dkwhatido := hzwhatido.Fun.(*ast.SelectorExpr).Sel.Name
			if dkwhatido == "Printf" {
				str1 := fset.Position(hzwhatido.Pos()).Line
				str2 := strings.Split(hzwhatido.Args[0].(*ast.BasicLit).Value, "\"")
				str3 := "\"" + strconv.Itoa(str1) + "(" + nameoffunc + "):" + strings.Join(str2, " ") + "\""
				hzwhatido.Args[0].(*ast.BasicLit).Value = str3
			}
		}
	}
	return true
})
```

# Тестирование
Исходная программа ```example.go```:
```golang
package main
import (
    "fmt"
)
var (
	a = 654
	b = false
)
func main() {
	fmt.Printf("asas %d", a)
	fmt.Printf("kukuuu %d", a)
}
func func1() {
	fmt.Printf("bababa %d", b)
}
```
Порождение новой программы ```example.go``` по преобразованному синтаксическому дереву:
```golang
import (
    "fmt"
)
var (
	a = 654
	b = false
)
func main() {
	fmt.Printf("13(main): asas %d ", a)
	fmt.Printf("14(main): kukuuu %d ", a)
}
func func1() {
	fmt.Printf("18(func1): bababa %d ", b)
}
```

# Вывод
в ходе выполнения лабораторной работы были изучены основные методы, типы и структуры библиотеки astprint - библиотеки для манипулирования абстрактным синтаксическим деревом (AST) своего кода. AST — важнейший компонент языка программирования Go, поскольку он представляет структуру кода и может использоваться для выполнения различных задач статического анализа. Таким образом, Astprint является важным инструментом для понимание своего кода и оптимизации производительности своего приложения. 
Разработанный код изменяет любые вызовы Printf в исходном файле Go, чтобы включить дополнительную информацию о местоположении и контексте вызова. Это может быть полезно для целей отладки и ведения журнала.
